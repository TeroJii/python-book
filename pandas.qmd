---
jupyter: python3
---

# Pandas

Pandas is Python library for data manipulation and analysis. It provides data structures like Series and DataFrame that are designed to work with structured data very easily and efficiently. It is built on top of NumPy. You can install pandas from the terminal using pip:

```bash
pip install pandas
```

## Series

Series is a one-dimensional labeled array capable of holding any data type (integers, strings, floating point numbers, Python objects, etc.). The axis labels are collectively referred to as the index. The basic method to create a Series is to call the series constructor:

```{python}
#| code-fold: false
# import numpy and pandas libraries
import numpy as np
import pandas as pd

# create a series from a list
pd.Series(data = [1, 2, 3, 4])
```

We can see that the series look very much like the list or a NumPy array. The series also has an index that can be used to access the elements of the series, but the difference is that we can specify the index values for our series:

```{python}
#| code-fold: false
# create a series with custom index
my_series = pd.Series(data = [1, 2, 3, 4], index = ['a', 'b', 'c', 'd'])
my_series
```

We can access the elements of the series using the index values:

```{python}
#| code-fold: false
# access the elements of the series
my_series['a']
```

You can also use the dot notation:

```{python}
#| code-fold: false
# access the elements of the series using the dot notation
my_series.b
```

### Creating a Series from other data types

A List is not the only data type that can be used to create a series. You can also use a dictionary:

```{python}
#| code-fold: false

# creating a series from a dictionary
my_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
pd.Series(my_dict)
```

You can also create a series from a NumPy array etc.

```{python}	
#| code-fold: false

# creating a series from a NumPy array
my_array = np.array([1, 2, 3, 4])
pd.Series(my_array)
```

### Accessing elements of a Series

We already saw the bracket + index and the dot + index notation in action. In addition to using the index, we can use the `iloc` attribute to access the elements of the series by using numerical indexing:

```{python}
#| code-fold: false
# access the first element of the series by using the positional index
my_series.iloc[0]
```

You can also use the `loc` attribute to access the elements of the series by their index. You can add multiple index values to access multiple elements:

```{python}
#| code-fold: false

# access the elements of the series by their index
my_series.loc[['a', 'c']]
```

We can also use the `:` operator to access a range of elements:

```{python}
#| code-fold: false

# access a range of elements
my_series.loc['a':'c']
```

Assigning values to the elements of the series is also possible and works in the same way as with NumPy arrays:

```{python}
#| code-fold: false

# assign a value to an element of the series
my_series['a'] = 100
my_series
```

## DataFrame

A DataFrame is a two-dimensional, size-mutable, and heterogeneous tabular data structure with labeled axes (rows and columns). You can think of being similar to a spreadsheet. It is generally the most commonly used pandas object. Like the Series object we learned earlier, the DataFrame also accepts many different kinds of input. Let's see what a DataFrame looks like:

```{python}
#| code-fold: false

# create a DataFrame from a dictionary
data = {'name': ['John', 'Anna', 'Peter', 'Linda'],
        'age': [23, 36, 32, 45],
        'city': ['New York', 'Paris', 'Berlin', 'London']}

df = pd.DataFrame(data)
df
```

We can see that the DataFrame has a default index that starts from 0, and that the data is displayed in a tabular format which makes it easy to read. We can also specify the index values:

```{python}
#| code-fold: false

# create a DataFrame with custom index
df = pd.DataFrame(data, index = ['a', 'b', 'c', 'd'])
df
```

### Accessing Columns of a DataFrame

The columns are actually Pandas Series objects. We can access the columns of the DataFrame using the column name and the bracket notation. Let's access the 'name' column of the DataFrame:

```{python}
#| code-fold: false

# access the first column of the DataFrame
df['name']
```

Let's inspect the type of the column:

```{python}
#| code-fold: false
type(df['name'])
```

We can see that the column is a Pandas Series object. We can also access the columns using the dot notation:

```{python}
#| code-fold: false
df.name
```

The issue that we may run into using the dot notation is that it may not work if the column we are trying to access has the same name as a DataFrame method. For example, if we have a column named 'count', we cannot access it using the dot notation because 'count' is a DataFrame method. We can access the columns using the `loc` attribute:

```{python}
#| code-fold: false

# add count column to the DataFrame
df['count'] = [1, 2, 3, 4]
df
```

We can access the columns using the `loc` attribute:

```{python}
#| code-fold: false

# access the columns of the DataFrame using the loc attribute
df.loc[:, 'count']
```

As we saw above, we can create a new column by assigning a list to a new column name. We can also create a new column by using the existing columns:

```{python}
#| code-fold: false

# create a new column by using the existing columns
df['age_plus_count'] = df['age'] + df['count']
df
```

If we now want to access all the new columns we created, we can use the bracket notation:

```{python}
#| code-fold: false

# access the new columns
df[['count', 'age_plus_count']]
```